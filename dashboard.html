<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="author" content="Mr Dubem" />
  <meta name="description" content="WireConnect Frontend" />
  <meta name="keywords" content="WireConnect, technicians, jobs" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>GTAN</title>
  <style>
    /* reset */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: Georgia, "Times New Roman", Times, serif; -webkit-text-size-adjust: 100%; }

    /* header logo (covers top) */
    :root { --header-h: 110px; } /* slightly reduced so more space on mobile */
    .bend {
      position: fixed; top: 0; left: 0; right: 0;
      height: var(--header-h); z-index: 1000;
      background: #fff; border-bottom: 1px solid #000;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
    }
    .bend figure { width:100%; height:100%; margin:0; }
    .bend figure img { width:100%; height:100%; display:block; }

    /* push page content below header */
    main { padding-top: var(--header-h); min-height: calc(100vh - var(--header-h)); }

    /* motto row and online indicator */
    .brief{
      color:black;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 14px;
      font-weight:bold;
      font-style:italic;
    }
    .brief .left { display:flex; align-items:center; gap:10px; min-width:0; }
    .brief .right { display:flex; align-items:center; gap:8px; }

    /* TITLE: reduced to fit phones (this was main overflow) */
    .sort { color: rgba(0,0,200,1); padding: 8px 12px; margin-bottom: 6px; text-align:left; }
    .sort .dent {
      /* reduced: min 30px, scale with viewport, max 56px */
      font-size: clamp(30px, 8vw, 56px);
      line-height: 1;
      font-weight: 700;
      color: rgba(0,0,200,1);
      word-break: break-word;
    }

    /* paragraph text responsive */
    .fit { padding: 12px 16px; font-size: clamp(15px, 3.5vw, 20px); line-height: 1.6; color:#111; }

    /* BUTTONS: neat, identical borders and size
       ----- ONLY BUTTON STYLES UPDATED BELOW -----
    */
    .audits {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 18px;
      padding: 18px 12px;
      flex-wrap: wrap;
    }

    .audit p, .audits p, .auditss p { margin: 0; width: auto; display:flex; align-items:center; justify-content:center; }

.audit{
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 18px;
      padding: 18px 2px;
      flex-wrap: wrap;
    }

    .audit p{ margin: 0; width: auto; display:flex; align-items:center; justify-content:center; }

 .too{ display:inline-flex;
      align-items:center;
      justify-content:center;
      text-decoration:none;
      border-radius: 30px;
      background: linear-gradient(#1154ff,#0738d6); /* strong blue gradient */
      color:#ffffff;
      padding:20px 10px;
      height: 10px;
      min-width: 180px;
      border: 4px solid #000;           /* bold black border like screenshot */
      font-weight:800;
      font-size: 18px;
      line-height:1;
      text-align:center;
      white-space: normal;
      word-break: break-word;
      /* subtle inner shadow to mimic the "pressed" look */
      box-shadow: inset 0 -6px 0 rgba(0,0,0,0.15), 0 6px 0 rgba(0,0,0,0.08);
    }

    /* NEW BUTTON STYLE: looks like your screenshot */
    .do{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      text-decoration:none;
      border-radius: 30px;
      background: linear-gradient(#1154ff,#0738d6); /* strong blue gradient */
      color:#ffffff;
      padding:40px 40px;
      height: 45px;
      min-width: 500px;
      border: 4px solid #000;           /* bold black border like screenshot */
      font-weight:800;
      font-size: 18px;
      line-height:1;
      text-align:center;
      white-space: normal;
      word-break: break-word;
      /* subtle inner shadow to mimic the "pressed" look */
      box-shadow: inset 0 -6px 0 rgba(0,0,0,0.15), 0 6px 0 rgba(0,0,0,0.08);
    }
     .to {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      text-decoration:none;
      border-radius: 30px;
      background: linear-gradient(#1154ff,#0738d6); /* strong blue gradient */
      color:#ffffff;
      padding:10px 10px;
      height: 45px;
      min-width: 180px;
      border: 4px solid #000;           /* bold black border like screenshot */
      font-weight:800;
      font-size: 18px;
      line-height:1;
      text-align:center;
      white-space: normal;
      word-break: break-word;
      /* subtle inner shadow to mimic the "pressed" look */
      box-shadow: inset 0 -6px 0 rgba(0,0,0,0.15), 0 6px 0 rgba(0,0,0,0.08);
    }
.doo{color:blue;
  text-decoration:none;
  font-weight:bold;
}
    /* small responsive tweaks for tiny phones */
    @media (max-width:480px){
      .do, .to { min-width: 46%; height:48px; font-size:15px; border-width:3px; border-radius:20px; padding:2px 56px; }
      .brief { padding: 12px; }
      .fit { padding: 10px 12px; }
    }

    /* leaderboard small buttons: keep the same look but smaller height */
    .auditss { display:flex; justify-content:center; gap:14px; padding: 18px 10px; }
    .auditss .to { min-width: 140px; height:44px; font-size:15px; }

    /* match small menu book button to same look */
    .menu-dropdown .book-btn {
      display:block;
      margin-top:6px;
      background: linear-gradient(#1154ff,#0738d6);
      color:#fff;
      padding:10px 12px;
      text-align:center;
      border-radius:10px;
      text-decoration:none;
      font-weight:800;
      border: 3px solid #000;
      box-shadow: inset 0 -4px 0 rgba(0,0,0,0.12), 0 4px 0 rgba(0,0,0,0.06);
    }

    /* keep regular menu links visible but not changed */
    .menu-dropdown a.menu-link { display:block; padding:8px; color:#000; font-weight:700; text-decoration:none; border-radius:6px; }

    /* KYC badge styles (added) */
    .kyc-badge {
      display:inline-block;
      margin-left:8px;
      padding:4px 8px;
      border-radius:999px;
      font-weight:700;
      font-size:12px;
      vertical-align:middle;
      color:#fff;
    }
    .kyc-unverified { background:#9aa0a6; } /* ash */
    .kyc-pending    { background:#f59e0b; } /* yellow */
    .kyc-verified   { background:#10b981; } /* green */
    .kyc-rejected   { background:#ef4444; } /* red */

    /* dot + blinking */
    .kdot {
      width:12px; height:12px; border-radius:50%;
      display:inline-block; margin-left:8px; vertical-align:middle;
      box-shadow:0 0 8px rgba(0,0,0,0.12);
      animation: kdot-blink 1s infinite;
    }
    @keyframes kdot-blink {
      0% { opacity:1; transform:scale(1); }
      50% { opacity:0.25; transform:scale(0.85); }
      100% { opacity:1; transform:scale(1); }
    }
    .kdot-unverified { background:#9aa0a6; box-shadow: 0 0 8px rgba(154,160,166,0.45); }
    .kdot-pending    { background:#f59e0b; box-shadow: 0 0 8px rgba(245,158,11,0.45); }
    .kdot-verified   { background:#10b981; box-shadow: 0 0 8px rgba(16,185,129,0.45); }
    .kdot-rejected   { background:#ef4444; box-shadow: 0 0 8px rgba(239,68,68,0.45); }

    /* small modal for "Do KYC?" (keeps visual minimal & consistent) */
    .book-kyc-backdrop {
      position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.45); z-index: 6000;
    }
    .book-kyc-modal {
      width: 92%; max-width: 420px; background: #fff; padding:16px; border-radius:10px; box-shadow: 0 18px 48px rgba(2,6,23,0.25);
      font-family: inherit;
    }
    .book-kyc-modal h4 { margin:0 0 8px; font-size:18px; }
    .book-kyc-modal .muted { color:#374151; margin-bottom:12px; font-size:14px; }
    .book-kyc-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
    .book-kyc-actions .btn {
      padding:8px 12px; border-radius:8px; border:0; font-weight:800; cursor:pointer;
      background: linear-gradient(#1154ff,#0738d6); color:#fff;
    }
    .book-kyc-actions .btn.alt { background:#fff; color:#111; border:1px solid #e6e9ef; font-weight:700; }

    /* keep existing button classes for Learn More, etc. */
    .image { background: rgba(220,220,220,1); padding: 10px 12px; margin: 8px 12px; border-radius:8px; }
    .images, .imagecap { display:flex; justify-content:center; padding: 12px 0; }
    .bond { padding:10px; }

    /* aside */
    aside { padding: 10px 14px 28px 14px; }

    /* chat bubble */
    .AI { position: fixed; right: 12px; bottom: 12px; z-index: 1200; }
    .AI img { width:64px; height:auto; border-radius:6px; display:block; }

    /* hamburger menu */
    .hamburger-container {
      position: fixed; top: calc(var(--header-h) - 36px); right: 12px; z-index: 2000;
    }
    .hamburger {
      font-size: 26px; padding:6px 10px; border-radius:8px; background:#fff; border:1px solid #000; cursor:pointer;
    }
    .menu-dropdown {
      display:none; position:absolute; right:0; margin-top:8px; width:260px;
      background:#fff; border:1px solid #000; border-radius:10px; padding:10px; box-shadow: 0 6px 18px rgba(0,0,0,.12);
    }

    /* toggle switch styles (kept) */
    .status-toggle { display:flex; justify-content:space-between; align-items:center; margin-top:8px; gap:8px; }
    .status-note { font-size:12px; color:#444; margin-top:6px; }
    .switch { position:relative; width:54px; height:30px; display:inline-block; }
    .switch input { display:none; }
    .slider { position:absolute; inset:0; background:#999; border-radius:30px; transition:.25s; }
    .slider:before { content:''; position:absolute; width:22px; height:22px; left:4px; bottom:4px; background:#fff; border-radius:50%; transition:.25s; box-shadow:0 2px 5px rgba(0,0,0,.2); }
    input:checked + .slider { background:#28a745; }
    input:checked + .slider:before { transform: translateX(24px); }

    /* online indicator */
    .online-indicator { display:inline-flex; align-items:center; gap:8px; font-weight:700; color:#333; }
    .indicator-dot { width:14px; height:14px; border-radius:50%; background:gray; display:inline-block; }
    .indicator-online { background:#28a745; box-shadow:0 0 8px rgba(40,167,69,.25); }
    .indicator-offline { background:gray; }

    /* toast */
    .toast { position: fixed; top: 12px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.85); color:#fff; padding:8px 12px; border-radius:8px; display:none; z-index:4000; }

    /* ensure images can't overflow horizontally */
    img { max-width:100%; height:auto; display:block; }
  </style>
</head>
<body data-user-id="">
  <!-- header (logo covers area) -->
  <header class="bend">
    <figure><img src="https://i.postimg.cc/ZRSK3pJx/IMG-20260202-144108.png" alt="WireConnect logo"></figure>
  </header>

  <!-- hamburger -->
  <div class="hamburger-container" aria-expanded="false">
    <button id="hamburgerBtn" class="hamburger" aria-controls="menuDropdown" aria-expanded="false">â˜°</button>
    <div id="menuDropdown" class="menu-dropdown" role="menu" aria-hidden="true">
      <a class="menu-link" href="profile.html">Profile</a>
      <a class="menu-link" href="settings.html">Settings</a>

      <!-- KYC link with badge & dot -->
      <a class="menu-link" href="kyc.html" id="kycMenuLink" style="display:flex;align-items:center;justify-content:space-between;">
        <span style="flex:1">KYC</span>
        <span style="display:inline-flex;align-items:center;gap:6px">
          <span id="kycBadge" class="kyc-badge kyc-unverified">Unverified</span>
          <span id="kycDot" class="kdot kdot-unverified" title="KYC status"></span>
        </span>
      </a>

      <!-- LOGOUT added above Book Job as requested -->
      <a id="logoutBtn" class="menu-link" href="#">Logout</a>

      <a class="book-btn" href="book.html">Book Job</a>

      <div class="status-toggle">
        <span>Status:</span>
        <label class="switch" title="Toggle online / offline">
          <input type="checkbox" id="statusSwitch" aria-label="Online toggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="status-note">Toggle to set client availability </div>
    </div>
  </div>

  <main>
    <p class="brief">
      <span class="left">Motto: Let Their Be Light ðŸ’¥ðŸ’¥</span>
      <span class="right">
        <span class="online-indicator" id="onlineIndicatorContainer" aria-live="polite">
          <span class="indicator-dot indicator-offline" id="indicatorDot"></span>
          <span id="indicatorText">Offline</span>
        </span>
      </span>
    </p>

    <div class="sort">
      <div class="dent">WireConnect Network</div>
    </div>

    <section class="fit">
      <p>WireConnect is a professional platform connecting skilled electrical technicians, verified service bookings, and trusted client projects. Built from Africa for the world, every connection supports real workmanship while enabling reliable service delivery.</p>
    </section>

    <div class="audit">
      <p><a class="do" href="book.html">Book A Job</a></p>
      <p><a class="do" href="#">View All Jobs</a></p>
    </div>

    <div class="audits">
      <p><a class="too" href="#">Do Kyc</a></p>
      <p><a class="too" href="#">Customer Services</a></p>
    </div>

    <div class="auditss">
      <p><a class="to" href="#">Client Leaderboard</a></p>
      <p><a class="to" href="#">Job Rules</a></p>
    </div>

    <article class="image">
      <figure class="images"><img src="https://i.postimg.cc/904qWnn7/icon-service-1.png" alt="decentralized"></figure>
      <p class="imagecap">Distributed Network</p>
      <p style="padding:0 12px 12px 12px;">Centralised platforms have a single point of failure: if the system breaks, the entire network is stalled until the issue is resolved. Wire Connect avoids this risk by operating through a distributed service network, designed for reliability, transparency, and uninterrupted operations.</p>

      <figure class="images"><img src="https://i.postimg.cc/Y2Gs5tzZ/icon-service-2.png" alt="Your secure way"></figure>
      <p class="imagecap">Your Secure Way to Services</p>
      <p style="padding:0 12px 12px 12px;">The WireConnect platform is designed for everyday use. Secure, simple, and reliable, it allows clients to find, book, and manage technicians with ease. It also integrates a feature â€” verified professionals accessible through your requests.</p>

      <figure class="images"><img src="https://i.postimg.cc/X7vms9Dk/icon-service-3.png" alt="Hub"></figure>
      <p class="imagecap">Wire Connect Hub</p>
      <p class="bond" style="padding:0 12px 12px 12px;">Empowering the Next Generation of Technicians. The WireConnect Hub connects skilled professionals with active clients. It offers a fair and transparent platform for technicians to get jobs, while giving clients early access to vetted experts.</p>
    </article>

    <aside>
      <figure style="margin-bottom:10px;"><img src="https://i.postimg.cc/hPzWS9bF/service-image-1.png" alt="meet image" style="max-width:280px;margin:auto;"></figure>
      <h2 style="padding:0 12px 8px 12px;">Meet the WireConnect Network</h2>
      <p style="padding:0 12px;"><strong>The WireConnect Network</strong> is more than a platform â€” itâ€™s a movement. Every part of our system is designed to empower skilled technicians, build trust, and drive community growth across Africa and beyond.</p>

      <ul style="margin:12px;padding-left:18px;">
        <li><strong>Service with Purpose:</strong> A portion of every connection supports widows, the elderly, and vulnerable communities, making real impact where itâ€™s needed most.</li>
        <li><strong>Wire Connect Hub:</strong> A transparent platform helping skilled technicians secure jobs, giving clients early access to vetted professionals.</li>
        <li><strong>Powered by Community:</strong> At Wire Connect, people come first. Our community drives growth, trust, and lasting impact across the platform.</li>
      </ul>

      <a class="doo" href="#" style="display:inline-block; margin:6px 12px;">Learn More</a>
    </aside>

    <aside class="AI"><a href="#"><img src="https://i.postimg.cc/66GgyB9s/chat-traditional-1.jpg" alt="chat"></a></aside>
  </main>

  <div class="toast" id="toast"></div>

  <!-- Book KYC Prompt Modal (keeps the book button enabled, shows prompt only) -->
  <div id="bookKycBackdrop" class="book-kyc-backdrop" aria-hidden="true">
    <div class="book-kyc-modal" role="dialog" aria-modal="true" aria-labelledby="bookKycTitle">
      <h4 id="bookKycTitle">Verify your account to unlock trust</h4>
      <div class="muted" id="bookKycMessage">We noticed your account is not verified. Verifying your identity helps you get more trusted bookings and access to higher-value jobs.</div>
      <div class="book-kyc-actions">
        
        <button id="bookKycDo" class="btn">Do KYC now</button>
      </div>
    </div>
  </div>

  <script>
    // backend base
    const API_BASE = 'https://wireconnet-1.onrender.com';

    // UI elements
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const menuDropdown = document.getElementById('menuDropdown');
    const statusSwitch = document.getElementById('statusSwitch');
    const indicatorDot = document.getElementById('indicatorDot');
    const indicatorText = document.getElementById('indicatorText');
    const toastEl = document.getElementById('toast');
    const logoutBtn = document.getElementById('logoutBtn');

    // KYC elements
    const kycBadge = document.getElementById('kycBadge');
    const kycDot = document.getElementById('kycDot');
    const kycMenuLink = document.getElementById('kycMenuLink');

    // Book prompt modal elements
    const bookKycBackdrop = document.getElementById('bookKycBackdrop');
    const bookKycMessage = document.getElementById('bookKycMessage');
    const bookKycDo = document.getElementById('bookKycDo');
    const bookKycContinue = document.getElementById('bookKycContinue');

    // small helper: show toast
    function showToast(msg, ms = 3000){
      toastEl.innerText = msg;
      toastEl.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toastEl.style.display = 'none', ms);
    }

    function setIndicator(online){
      if(online){
        indicatorDot.classList.remove('indicator-offline');
        indicatorDot.classList.add('indicator-online');
        indicatorText.innerText = 'Online';
      } else {
        indicatorDot.classList.remove('indicator-online');
        indicatorDot.classList.add('indicator-offline');
        indicatorText.innerText = 'Offline';
      }
    }

      // get user from storage (try wc_user object then fallback)
    function getLocalUser(){
      try {
        const raw = localStorage.getItem('wc_user');
        if(raw){
          const u = JSON.parse(raw);
          return u || null;
        }
      } catch(e){}
      try {
        const id = localStorage.getItem('userId');
        const role = localStorage.getItem('userRole');
        if(id) return { id, role: role || null };
      } catch(e){}
      return null;
    }

    function getUserId(){
      const u = getLocalUser();
      if(u && u.id) return u.id;
      const bodyId = document.body.getAttribute('data-user-id');
      return bodyId && bodyId.trim() !== '' ? bodyId : null;
    }

    function getUserRole(){
      const u = getLocalUser();
      if(u && u.role) return u.role;
      return null;
    }

    function storeLastKnownOnline(userId, online){
      if(!userId) return;
      try { localStorage.setItem('techOnline_' + userId, online ? '1' : '0'); } catch(e){}
    }
    function readLastKnownOnline(userId){
      if(!userId) return null;
      try { const v = localStorage.getItem('techOnline_' + userId); return v === null ? null : v === '1'; } catch(e){ return null; }
    }

    async function sendStatusToBackend(userId, online, lat = null, lng = null){
      const url = API_BASE + '/api/tech/status';
      const controller = new AbortController();
      const timeout = setTimeout(()=> controller.abort(), 12000);
      try {
        const resp = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          signal: controller.signal,
          body: JSON.stringify({ techId: userId, online: !!online, lat: lat, lng: lng })
        });
        clearTimeout(timeout);
        const json = await resp.json().catch(()=> null);
        if(!resp.ok) return { success:false, message: (json && json.message) ? json.message : ('HTTP ' + resp.status) };
        return json;
      } catch(err){
        clearTimeout(timeout);
        if(err.name === 'AbortError') return { success:false, message:'Request timed out' };
        return { success:false, message: err.message || 'Network error' };
      }
    }

    // ---------- KYC badge logic ----------
    // currentKycStatus: 'verified'|'pending'|'rejected'|'unverified'|null
    let currentKycStatus = null;

    async function updateKycBadge(){
      try {
        const userId = getUserId();
        if(!userId){
          if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Not signed in'; }
          if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Not signed in'; }
          currentKycStatus = 'unverified';
          return;
        }

        const url = API_BASE + '/api/kyc/status/' + encodeURIComponent(userId);
        const resp = await fetch(url, { method:'GET' });
        if(!resp.ok){
          if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Unable to fetch status'; }
          if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Unable to fetch status'; }
          currentKycStatus = 'unverified';
          return;
        }

        const data = await resp.json().catch(()=>null);
        if(!data){
          if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; }
          if(kycDot){ kycDot.className = 'kdot kdot-unverified'; }
          currentKycStatus = 'unverified';
          return;
        }

        const latest = data.latest_request || null;
        const user = data.user || null;
        let status = null;
        if(latest && latest.status) status = String(latest.status).toLowerCase();
        else if(user && user.kyc_status) status = String(user.kyc_status).toLowerCase();

        let label = 'Unverified';
        let badgeClass = 'kyc-badge kyc-unverified';
        let dotClass = 'kdot kdot-unverified';
        let normalized = 'unverified';

        if(status){
          if(status === 'pending'){ label = 'Pending'; badgeClass = 'kyc-badge kyc-pending'; dotClass = 'kdot kdot-pending'; normalized = 'pending'; }
          else if(status === 'approved' || status === 'verified'){ label = 'Verified'; badgeClass = 'kyc-badge kyc-verified'; dotClass = 'kdot kdot-verified'; normalized = 'verified'; }
          else if(status === 'declined' || status === 'rejected' || status === 'failed'){ label = 'Rejected'; badgeClass = 'kyc-badge kyc-rejected'; dotClass = 'kdot kdot-rejected'; normalized = 'rejected'; }
          else { label = status.charAt(0).toUpperCase() + status.slice(1); badgeClass = 'kyc-badge kyc-unverified'; dotClass = 'kdot kdot-unverified'; normalized = status; }
        }

        if(kycBadge){
          kycBadge.textContent = label;
          kycBadge.className = badgeClass;
          if(latest && latest.admin_note){
            kycBadge.title = 'Admin: ' + latest.admin_note;
          } else if(latest && latest.submitted_at){
            try { kycBadge.title = `Submitted: ${new Date(latest.submitted_at).toLocaleString()}` } catch(e){ kycBadge.title = `Submitted: ${latest.submitted_at}` }
          } else if(user && user.kyc_submitted_at){
            try { kycBadge.title = `Submitted: ${new Date(user.kyc_submitted_at).toLocaleString()}` } catch(e){ kycBadge.title = `Submitted: ${user.kyc_submitted_at}` }
          } else {
            kycBadge.title = `KYC status: ${label}`;
          }
        }
        if(kycDot){
          kycDot.className = dotClass;
          if(latest && latest.admin_note) kycDot.title = 'Admin: ' + latest.admin_note;
          else kycDot.title = 'KYC: ' + label;
        }
        currentKycStatus = normalized;
      } catch(err){
        console.warn('updateKycBadge error', err);
        if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Error'; }
        if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Error'; }
        currentKycStatus = 'unverified';
      }
    }

    // run on load and periodically
    (function startKycPolling(){
      updateKycBadge();
      setInterval(updateKycBadge, 15000); // refresh every 15s
    })();

    // intercept clicks to kyc.html: if verified, block and show message
    function interceptKycLinks(){
      const anchors = Array.from(document.querySelectorAll('a[href$="kyc.html"], a[href*="/kyc.html"]'));
      anchors.forEach(a => {
        if(a.dataset.kycHandlerAttached) return;
        a.dataset.kycHandlerAttached = '1';
        a.addEventListener('click', function(ev){
          try {
            if(currentKycStatus === null) { updateKycBadge(); }
            if(currentKycStatus === 'verified'){
              ev.preventDefault(); ev.stopPropagation();
              showToast('Account already verified â€” no need to open KYC page.', 4000);
              return false;
            }
            // otherwise allow navigation
          } catch(e){
            console.warn('KYC link handler error', e);
          }
        }, { passive: false });
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      interceptKycLinks();
      // re-run intercept periodically to catch dynamically added links
      setInterval(interceptKycLinks, 3000);
    });

    // ---------- BOOK button interception (new) ----------
    // Keep the button enabled. On click: check KYC and if not verified show a friendly modal with two choices.
    (function attachBookHandler(){
      // find primary Book A Job anchor - prefer the main large button (class 'do' linking to book.html)
      const bookAnchor = document.querySelector('a.do[href="book.html"], a.book-btn[href="book.html"], a[href="book.html"]');
      if(!bookAnchor) return;
      // make sure we only bind once
      if(bookAnchor.dataset.bookHandlerAttached) return;
      bookAnchor.dataset.bookHandlerAttached = '1';

      bookAnchor.addEventListener('click', async function(ev){
        // allow open-in-new-tab and modifier keys to function normally
        if(ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey) return;
        ev.preventDefault();

        // ensure latest kyc status is loaded
        await updateKycBadge();

        // if verified -> navigate
        if(currentKycStatus === 'verified'){
          window.location.href = bookAnchor.href;
          return;
        }

        // otherwise show prompt - keep the button enabled (user can still choose Continue to Book)
        // Craft message depending on status (admin note if rejected)
        let message = `Your account is currently "${currentKycStatus || 'unverified'}". Verifying your identity improves trust and may be required for some jobs.`;
        try {
          // try to fetch admin note from /api/kyc/status/:userId for extra context (non-blocking)
          const uid = getUserId();
          if(uid){
            const resp = await fetch(API_BASE + '/api/kyc/status/' + encodeURIComponent(uid));
            if(resp.ok){
              const data = await resp.json().catch(()=>null);
              const latest = data && data.latest_request ? data.latest_request : null;
              if(latest && latest.admin_note){
                message += '\n\nAdmin note: ' + latest.admin_note;
              }
            }
          }
        } catch(e){ /* ignore errors */ }

        // show modal (fill message)
        bookKycMessage.innerText = message;
        bookKycBackdrop.style.display = 'flex';
        bookKycBackdrop.setAttribute('aria-hidden','false');

        // attach handlers (one-time)
        bookKycDo.onclick = function(){
          bookKycBackdrop.style.display = 'none';
          try { window.location.href = 'kyc.html'; } catch(e){ /* fallback */ window.location.assign('kyc.html'); }
        };
        bookKycContinue.onclick = function(){
          bookKycBackdrop.style.display = 'none';
          // continue to the booking flow
          try { window.location.href = bookAnchor.href; } catch(e){ window.location.assign(bookAnchor.href); }
        };
      }, { passive: false });
    })();

    // ---------- rest of your existing logic (unchanged) ----------

    // hamburger toggle (unchanged)
    (function(){
      const btn = hamburgerBtn, menu = menuDropdown;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const shown = menu.style.display === 'block';
        menu.style.display = shown ? 'none' : 'block';
        btn.setAttribute('aria-expanded', String(!shown));
        menu.setAttribute('aria-hidden', String(shown));
      });
      document.addEventListener('click', (e) => {
        const container = document.querySelector('.hamburger-container');
        if(!container.contains(e.target)){
          menu.style.display = 'none';
          btn.setAttribute('aria-expanded', 'false');
          menu.setAttribute('aria-hidden', 'true');
        }
      });
    })();

    // Toggle handler: ONLY ALLOW when user role === 'client'
    async function handleSwitchToggle(e){
      const checked = e.target.checked;

      // allow only for clients
      const role = getUserRole();
      const isClient = role === 'client';
      if(!isClient){
        // revert
        if(statusSwitch) statusSwitch.checked = false;
        showToast('Availability toggle works only when a client is signed in.', 4500);
        return;
      }

      const userId = getUserId();
      if(!userId){
        if(statusSwitch) statusSwitch.checked = false;
        showToast('No user id found. Set body[data-user-id] or localStorage.userId to enable status updates.', 5000);
        return;
      }

      // best-effort geolocation
      let lat = null, lng = null;
      if(navigator.geolocation){
        try{
          const pos = await new Promise((resolve, reject) => {
            const t = setTimeout(()=> reject(new Error('geolocation timeout')), 4500);
            navigator.geolocation.getCurrentPosition(p => { clearTimeout(t); resolve(p); }, err => { clearTimeout(t); reject(err); }, { maximumAge: 10000, timeout:4500 });
          });
          lat = pos.coords.latitude; lng = pos.coords.longitude;
        }catch(err){ /* ignore */ }
      }
      // optimistic UI update
      setIndicator(checked);
      if(statusSwitch) statusSwitch.disabled = true;
      showToast( checked ? 'Setting status to Online...' : 'Setting status to Offline...', 2000 );

      const result = await sendStatusToBackend(userId, checked, lat, lng);
      if(statusSwitch) statusSwitch.disabled = false;

      if(result && result.success){
        storeLastKnownOnline(userId, checked);
        showToast('Status updated', 2000);
      } else {
        // revert
        const prev = !checked;
        if(statusSwitch) statusSwitch.checked = prev;
        setIndicator(prev);
        const msg = (result && result.message) ? result.message : 'Failed to update status';
        showToast('Error: ' + msg, 6000);
        console.warn('Status update failed:', result);
      }
    }

    // attach listener
    if(document.getElementById('statusSwitch')){
      document.getElementById('statusSwitch').addEventListener('change', handleSwitchToggle);
    }

    // initial UI state
    (function initFromLocal(){
      const role = getUserRole();
      const isClient = role === 'client';
      const userId = getUserId();
      const ss = document.getElementById('statusSwitch');

      if(!isClient){
        // leave UI unchanged visually but ensure switch is unchecked and indicator offline
        setIndicator(false);
        if(ss) ss.checked = false;
        return;
      }

      // for client, restore last known if any
      const known = readLastKnownOnline(userId);
      if(known === null){
        setIndicator(false);
        if(ss) ss.checked = false;
      } else {
        setIndicator(!!known);
        if(ss) ss.checked = !!known;
      }
    })();

    // LOGOUT: clear session-related keys and redirect to login.html
    logoutBtn && logoutBtn.addEventListener('click', function (ev) {
      ev.preventDefault();
      try {
        const u = getLocalUser();
        if(u && u.id) {
          // remove any per-user online flag
          localStorage.removeItem('techOnline_' + u.id);
        }
      } catch(e){}
      // clear common session keys used by your pages
      localStorage.removeItem('wc_user');
      localStorage.removeItem('wc_token');
      localStorage.removeItem('userId');
      localStorage.removeItem('userRole');
      // also remove generic online flag
      localStorage.removeItem('wc_online');
      // navigate to login
      window.location.href = 'login.html';
    });

    // close menu on ESC (unchanged)
    document.addEventListener('keydown', (e)=> {
      if(e.key === 'Escape') {
        const menu = document.getElementById('menuDropdown');
        const btn = document.getElementById('hamburgerBtn');
        if(menu) menu.style.display = 'none';
        if(btn) btn.setAttribute('aria-expanded', false);
        if(menu) menu.setAttribute('aria-hidden', true);
      }
    });
  </script>
</body>
</html>