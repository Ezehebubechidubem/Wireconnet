<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="author" content="Mr Dubem">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Technician</title>
  <style>
    /* Minimal changes: styles from your previous file kept, plus modal styles and blinking dot */
    * { box-sizing: border-box; margin:0; padding:0; }
    html,body { height:100%; font-family: Georgia, "Times New Roman", Times, serif; -webkit-text-size-adjust: 100%; background:#fff; }
    :root { --header-h:110px; --accent-blue: #1154ff; --accent-blue-dark:#0738d6; --black: #000; --green:#28a745; }
    .bend { position:fixed; top:0; left:0; right:0; height:var(--header-h); z-index:1000; background:#fff; border-bottom:1px solid var(--black); display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .bend figure { width:100%; height:100%; margin:0; }
    .bend figure img { width:100%; height:100%; display:block; }

    main { padding-top: var(--header-h); min-height: calc(100vh - var(--header-h)); }

    .brief{ color:black; display:flex; align-items:center; justify-content:space-between; gap:12px; padding: 14px 14px; font-weight:bold; font-style:italic; }
    .sort { color: rgba(0,0,200,1); padding:8px 12px; margin-bottom:6px; text-align:left; }
    .sort .dent { font-size: clamp(30px, 8vw, 56px); line-height:1; font-weight:700; color: rgba(0,0,200,1); word-break:break-word; }
    .fit { padding:12px 16px; font-size: clamp(15px, 3.5vw, 20px); line-height:1.6; color:#111; }

    /* Buttons (kept your look) */
    .audit, .audits, .auditss { display:flex; justify-content:center; gap:18px; padding:18px 12px; flex-wrap:wrap; }
    .do, .too, .to {
      display:inline-flex; align-items:center; justify-content:center; text-decoration:none; border-radius:30px;
      background: linear-gradient(var(--accent-blue), var(--accent-blue-dark)); color:#fff; font-weight:800;
      border:4px solid #000; box-shadow: inset 0 -6px 0 rgba(0,0,0,0.15), 0 6px 0 rgba(0,0,0,0.08);
    }
    .do { padding:12px 28px; min-width:180px; font-size:18px; height:48px; }
    .too { padding:10px 20px; min-width:160px; font-size:16px; height:44px; }
    .to  { padding:10px 18px; min-width:160px; font-size:16px; height:44px; }

    .image { background: rgba(220,220,220,1); padding:10px 12px; margin:8px 12px; border-radius:8px; }
    .images, .imagecap { display:flex; justify-content:center; padding:12px 0; }
    aside { padding:10px 14px 28px 14px; }

    .AI { position: fixed; right:12px; bottom:12px; z-index:1200; }
    .AI img { width:64px; height:auto; border-radius:6px; display:block; }

    /* Hamburger */
    .hamburger-container { position:fixed; top:calc(var(--header-h) - 36px); right:12px; z-index:2000; }
    .hamburger { font-size:26px; padding:6px 10px; border-radius:8px; background:#fff; border:1px solid #000; cursor:pointer; }
    .menu-dropdown { display:none; position:absolute; right:0; margin-top:8px; width:360px; background:#fff; border:1px solid #000; border-radius:10px; padding:12px; box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    .menu-dropdown a.menu-link { display:block; padding:8px; color:#000; font-weight:700; text-decoration:none; border-radius:6px; }
    .menu-dropdown .book-btn { display:block; margin-top:6px; background: linear-gradient(var(--accent-blue),var(--accent-blue-dark)); color:#fff; padding:10px 12px; text-align:center; border-radius:10px; text-decoration:none; font-weight:800; border:3px solid #000; box-shadow: inset 0 -4px 0 rgba(0,0,0,0.12), 0 4px 0 rgba(0,0,0,0.06); }

    /* KYC badge styles */
    .kyc-badge { display:inline-block; margin-left:8px; padding:3px 8px; border-radius:999px; font-weight:800; font-size:12px; vertical-align:middle; color:#fff; }
    .kyc-unverified { background:#9aa0a6; color:#fff; } /* ash */
    .kyc-pending { background:#f59e0b; color:#fff; } /* yellow/orange */
    .kyc-verified { background:#10b981; color:#fff; } /* green */
    .kyc-rejected { background:#ef4444; color:#fff; } /* red */

    /* blinking status dot */
    .kdot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-left:8px; vertical-align:middle; box-shadow: 0 0 10px rgba(0,0,0,0.12); animation: kdot-blink 1s infinite; }
    @keyframes kdot-blink {
      0%   { opacity:1; transform: scale(1); }
      50%  { opacity:0.25; transform: scale(0.85); }
      100% { opacity:1; transform: scale(1); }
    }
    .kdot-unverified { background:#9aa0a6; box-shadow: 0 0 8px rgba(154,160,166,0.45); }
    .kdot-pending   { background:#f59e0b; box-shadow: 0 0 8px rgba(245,158,11,0.45); }
    .kdot-verified  { background:#10b981; box-shadow: 0 0 8px rgba(16,185,129,0.45); }
    .kdot-rejected  { background:#ef4444; box-shadow: 0 0 8px rgba(239,68,68,0.45); }

    /* toggle */
    .status-toggle { display:flex; justify-content:space-between; align-items:center; margin-top:8px; gap:8px; }
    .switch { position:relative; width:54px; height:30px; display:inline-block; }
    .switch input { display:none; }
    .slider { position:absolute; inset:0; background:#999; border-radius:30px; transition:.25s; }
    .slider:before { content:''; position:absolute; width:22px; height:22px; left:4px; bottom:4px; background:#fff; border-radius:50%; transition:.25s; box-shadow:0 2px 5px rgba(0,0,0,.2); }
    input:checked + .slider { background:var(--green); }
    input:checked + .slider:before { transform: translateX(24px); }

    /* indicator */
    .online-indicator { display:inline-flex; align-items:center; gap:8px; font-weight:700; color:#333; }
    .indicator-dot { width:14px; height:14px; border-radius:50%; background:gray; display:inline-block; }
    .indicator-online { background:var(--green); box-shadow: 0 0 8px rgba(40,167,69,.25); }
    .indicator-offline { background:gray; }

    /* toast */
    .toast { position: fixed; top:12px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.85); color:#fff; padding:8px 12px; border-radius:8px; display:none; z-index:4000; }

    /* ------------- MODAL STYLES (new, neat popups) ------------- */
    .modal-backdrop{ position:fixed; inset:0; background: rgba(0,0,0,0.45); display:none; align-items:center; justify-content:center; z-index:5000; }
    .modal {
      width:92%; max-width:520px; background:#fff; border-radius:12px; padding:18px; box-shadow:0 20px 60px rgba(2,6,23,0.4);
      animation: popIn .16s ease;
    }
    @keyframes popIn { from { transform: translateY(8px) scale(.995); opacity:.0 } to { transform:none; opacity:1 } }
    .modal h3 { margin:0 0 8px; font-size:18px; }
    .modal .muted { color:#374151; font-size:14px; margin-bottom:8px; }
    .modal .tech-card{ display:flex; gap:12px; align-items:center; padding:8px; border-radius:10px; border:1px solid #eef6ff; background:#fbfeff; }
    .modal .tech-avatar{ width:64px; height:64px; object-fit:cover; border-radius:8px; background:#f0f3ff; }
    .modal .modal-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    .modal .btn { background:var(--accent-blue); color:#fff; padding:10px 12px; border-radius:8px; border:0; font-weight:800; cursor:pointer; }
    .modal .btn.secondary { background:#f3f4f6; color:#111; border:1px solid #e6eef9; }
    .modal .countdown { font-weight:800; font-size:18px; text-align:center; margin-top:8px; padding:8px 0; background:#f8fafc; border-radius:8px; }

    /* small screens: ensure buttons don't overflow */
    @media (max-width:480px) {
      .do { min-width:46%; padding:10px 8px; font-size:15px; height:44px; border-width:3px; border-radius:20px; }
      .to { min-width:44%; font-size:14px; height:44px; }
      .modal { padding:12px; }
      .menu-dropdown { width:95vw; }
    }
  </style>
</head>
<body data-user-id="">
  <header class="bend">
    <figure><img src="https://i.postimg.cc/ZRSK3pJx/IMG-20260202-144108.png" alt="WireConnect logo"></figure>
  </header>

  <div class="hamburger-container" aria-expanded="false">
    <button id="hamburgerBtn" class="hamburger" aria-controls="menuDropdown" aria-expanded="false">â˜°</button>
    <div id="menuDropdown" class="menu-dropdown" role="menu" aria-hidden="true">
      <a class="menu-link" href="profile.html">Profile</a>
      <a class="menu-link" href="settings.html">Settings</a>
      <!-- KYC link with dynamic badge and blinking dot -->
      <a class="menu-link" href="kyc.html" id="kycMenuLink" style="display:flex;align-items:center;justify-content:space-between;">
        <span style="flex:1">KYC</span>
        <span style="display:inline-flex;align-items:center;gap:6px">
          <span id="kycBadge" class="kyc-badge kyc-unverified" aria-live="polite">Unverified</span>
          <span id="kycDot" class="kdot kdot-unverified" aria-hidden="true" title="KYC status"></span>
        </span>
      </a>
      <a id="logoutBtn" class="menu-link" href="#">Logout</a>
      <div class="status-toggle">
        <span>Status:</span>
        <label class="switch" title="Toggle online / offline">
          <input type="checkbox" id="statusSwitch" aria-label="Online toggle"><span class="slider"></span>
        </label>
      </div>
      <div class="status-note">Toggle to set technician availability</div>
    </div>
  </div>

  <main>
    <p class="brief">
      <span class="left">Motto: Let Their Be Light ðŸ’¥ðŸ’¥</span>
      <span class="right">
        <span class="online-indicator" id="onlineIndicatorContainer" aria-live="polite">
          <span class="indicator-dot indicator-offline" id="indicatorDot"></span>
          <span id="indicatorText">Offline</span>
        </span>
      </span>
    </p>

    <div class="sort">
      <div class="dent">WireConnect Network</div>
    </div>

    <section class="fit">
      <p>WireConnect is a professional platform connecting skilled electrical technicians, verified service bookings, and trusted client projects. Built from Africa for the world, every connection supports real workmanship while enabling reliable service delivery.</p>
    </section>

    <div class="audit">
      <p><a id="jobMapBtn" class="do" href="javascript:void(0)">Job Map</a></p>
      <p><a id="viewJobsBtn" class="do" href="javascript:void(0)">View All Jobs</a></p>
    </div>

    <div class="audits">
      <p><a class="too" href="kyc.html">Do Kyc</a></p>
      <p><a class="too" href="#">Customer Services</a></p>
    </div>

    <div class="auditss">
      <p><a id="jobRulesBtn" class="to" href="javascript:void(0)">Job Rules</a></p>
      <p><a id="techLeaderboardBtn" class="to" href="javascript:void(0)">Technician Leaderboard</a></p>
    </div>

    <article class="image">
      <figure class="images"><img src="https://i.postimg.cc/904qWnn7/icon-service-1.png" alt="decentralized"></figure>
      <p class="imagecap">Distributed Network</p>
      <p style="padding:0 12px 12px 12px;">Centralised platforms have a single point of failure: if the system breaks, the entire network is stalled until the issue is resolved. Wire Connect avoids this risk by operating through a distributed service network, designed for reliability, transparency, and uninterrupted operations.</p>
    </article>

    <aside>
      <figure style="margin-bottom:10px;"><img src="https://i.postimg.cc/hPzWS9bF/service-image-1.png" alt="meet image" style="max-width:280px;margin:auto;"></figure>
      <h2 style="padding:0 12px 8px 12px;">Meet the WireConnect Network</h2>
      <p style="padding:0 12px;"><strong>The WireConnect Network</strong> is more than a platform â€” itâ€™s a movement. Every part of our system is designed to empower skilled technicians, build trust, and drive community growth across Africa and beyond.</p>
      <ul style="margin:12px;padding-left:18px;">
        <li><strong>Service with Purpose:</strong> A portion of every connection supports widows, the elderly, and vulnerable communities, making real impact where itâ€™s needed most.</li>
        <li><strong>Wire Connect Hub:</strong> A transparent platform helping skilled technicians secure jobs, giving clients early access to vetted professionals.</li>
        <li><strong>Powered by Community:</strong> At Wire Connect, people come first. Our community drives growth, trust, and lasting impact across the platform.</li>
      </ul>
      <a class="too" href="#" style="display:inline-block; margin:6px 12px;">Learn More</a>
    </aside>

    <aside class="AI"><a href="#"><img src="https://i.postimg.cc/66GgyB9s/chat-traditional-1.jpg" alt="chat"></a></aside>
  </main>

  <!-- toast -->
  <div class="toast" id="toast"></div>

  <!-- MODAL: single modal used for all popups -->
  <div id="mainModalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="mainModal">
      <!-- content injected dynamically -->
    </div>
  </div>

  <script>
    const API_BASE = 'https://wireconnet-1.onrender.com';

    // Controls
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const menuDropdown = document.getElementById('menuDropdown');
    const statusSwitch = document.getElementById('statusSwitch');
    const indicatorDot = document.getElementById('indicatorDot');
    const indicatorText = document.getElementById('indicatorText');
    const toastEl = document.getElementById('toast');

    const kycBadge = document.getElementById('kycBadge');
    const kycDot = document.getElementById('kycDot');
    const kycMenuLink = document.getElementById('kycMenuLink');
    const logoutBtn = document.getElementById('logoutBtn');

    // modal
    const modalBackdrop = document.getElementById('mainModalBackdrop');
    const modal = document.getElementById('mainModal');

    // keep timers for pending jobs
    const pendingTimers = {}; // jobId -> { timeoutId }

    // holds the normalized current status: 'verified'|'pending'|'rejected'|'unverified'|null
    let currentKycStatus = null;

    // util to show toast
    function showToast(msg, ms = 3000){
      toastEl.innerText = msg;
      toastEl.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toastEl.style.display = 'none', ms);
    }

    function setIndicator(online){
      if(online){
        indicatorDot.classList.remove('indicator-offline');
        indicatorDot.classList.add('indicator-online');
        indicatorText.innerText = 'Online';
      } else {
        indicatorDot.classList.remove('indicator-online');
        indicatorDot.classList.add('indicator-offline');
        indicatorText.innerText = 'Offline';
      }
    }

    // local user helpers (wc_user)
    function getLocalUser(){
      try { const raw = localStorage.getItem('wc_user'); if(raw) return JSON.parse(raw); } catch(e){}
      try { const id = localStorage.getItem('userId'); const role = localStorage.getItem('userRole'); if(id) return { id, role }; } catch(e){}
      return null;
    }
    function getUserId(){ const u = getLocalUser(); if(u && u.id) return u.id; const bodyId = document.body.getAttribute('data-user-id'); return bodyId && bodyId.trim() !== '' ? bodyId : null; }
    function getUserRole(){ const u = getLocalUser(); if(u && u.role) return u.role; return null; }
    function isTechnicianRole(role){ if(!role) return false; const r = role.toString().toLowerCase(); return r === 'worker' || r.includes('tech') || r.includes('worker'); }

    // last-known store
    function storeLastKnownOnline(userId, online){ if(!userId) return; try { localStorage.setItem('techOnline_' + userId, online ? '1' : '0'); } catch(e){} }
    function readLastKnownOnline(userId){ if(!userId) return null; try { const v = localStorage.getItem('techOnline_' + userId); return v === null ? null : v === '1'; } catch(e){ return null; } }

    // send status
    async function sendStatusToBackend(userId, online, lat=null, lng=null){
      const url = API_BASE + '/api/tech/status';
      const controller = new AbortController();
      const timeout = setTimeout(()=> controller.abort(), 12000);
      try {
        const resp = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, signal:controller.signal, body: JSON.stringify({ techId: userId, online: !!online, lat, lng }) });
        clearTimeout(timeout);
        const json = await resp.json().catch(()=>null);
        if(!resp.ok) return { success:false, message: (json && json.message) ? json.message : ('HTTP ' + resp.status) };
        return json;
      } catch(err){
        clearTimeout(timeout);
        if(err.name === 'AbortError') return { success:false, message:'Request timed out' };
        return { success:false, message: err.message || 'Network error' };
      }
    }

    // Fetch assigned jobs
    async function fetchAssignedJobs(techId){
      try {
        const url = API_BASE + '/api/assigned-jobs?techId=' + encodeURIComponent(techId);
        const resp = await fetch(url, { method:'GET', headers:{ 'Content-Type':'application/json' } });
        if(!resp.ok) return null;
        const data = await resp.json().catch(()=>null);
        if(!data || !data.success) return null;
        return data.jobs || [];
      } catch(err){
        console.warn('fetchAssignedJobs error', err);
        return null;
      }
    }

    // ---------- MODAL helpers (beautiful) ----------
    function openModal(htmlContent, { onClose=null, closable=true } = {}){
      modal.innerHTML = htmlContent;
      modalBackdrop.style.display = 'flex';
      modalBackdrop.setAttribute('aria-hidden','false');
      modal._onClose = onClose;
      modal._closable = !!closable;
    }
    function closeModal(){
      modalBackdrop.style.display = 'none';
      modalBackdrop.setAttribute('aria-hidden','true');
      if(typeof modal._onClose === 'function') { try{ modal._onClose(); }catch(e){ console.warn(e); } }
      modal._onClose = null;
    }

    // show a small info modal (used when KYC verified)
    function showInfoModal(title, message){
      const html = `
        <h3>${title}</h3>
        <div class="muted">${String(message)}</div>
        <div class="modal-actions"><button id="infoOk" class="btn">OK</button></div>
      `;
      openModal(html, { closable:true });
      document.getElementById('infoOk').addEventListener('click', closeModal);
    }

    // showErrorPopup helper
    function showErrorPopup(title, message){
      const html = `
        <h3>${title}</h3>
        <div class="muted">${String(message)}</div>
        <div class="modal-actions"><button id="errClose" class="btn">OK</button></div>
      `;
      openModal(html, { closable:true });
      document.getElementById('errClose').addEventListener('click', closeModal);
    }

    // Nicely update KYC badge & blinking dot in hamburger menu
    async function updateKycBadge(){
      try {
        const userId = getUserId();
        if(!userId){
          if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Not signed in'; }
          if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Not signed in'; }
          currentKycStatus = 'unverified';
          return;
        }
        const resp = await fetch(API_BASE + '/api/kyc/status/' + encodeURIComponent(userId));
        if(!resp.ok){
          if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Unable to fetch status'; }
          if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Unable to fetch status'; }
          currentKycStatus = 'unverified';
          return;
        }
        const j = await resp.json().catch(()=>null);
        if(!j) { if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; } if(kycDot){ kycDot.className = 'kdot kdot-unverified'; } currentKycStatus = 'unverified'; return; }
        const latest = j.latest_request || null;
        const user = j.user || null;
        let status = null;
        if(latest && latest.status) status = String(latest.status).toLowerCase();
        else if(user && user.kyc_status) status = String(user.kyc_status).toLowerCase();

        let label = 'Unverified';
        let cls = 'kyc-badge kyc-unverified';
        let dotCls = 'kdot kdot-unverified';
        let normalized = 'unverified';
        if(status){
          if(status === 'pending') { label = 'Pending'; cls = 'kyc-badge kyc-pending'; dotCls = 'kdot kdot-pending'; normalized = 'pending'; }
          else if(status === 'approved' || status === 'verified') { label = 'Verified'; cls = 'kyc-badge kyc-verified'; dotCls = 'kdot kdot-verified'; normalized = 'verified'; }
          else if(status === 'declined' || status === 'rejected' || status === 'failed') { label = 'Rejected'; cls = 'kyc-badge kyc-rejected'; dotCls = 'kdot kdot-rejected'; normalized = 'rejected'; }
          else if(status === 'not_required' || status === 'not_submitted' || status === 'unverified' || status === 'none') { label = 'Unverified'; cls = 'kyc-badge kyc-unverified'; dotCls = 'kdot kdot-unverified'; normalized = 'unverified'; }
          else { label = status.charAt(0).toUpperCase() + status.slice(1); cls = 'kyc-badge kyc-unverified'; dotCls = 'kdot kdot-unverified'; normalized = status; }
        }

        if(kycBadge){
          kycBadge.textContent = label;
          kycBadge.className = cls;
          if(latest && latest.admin_note){
            kycBadge.title = 'Admin: ' + latest.admin_note;
          } else {
            if(latest && latest.submitted_at){
              const dateStr = new Date(latest.submitted_at).toLocaleString();
              kycBadge.title = `KYC ${label} â€¢ submitted: ${dateStr}`;
            } else if(user && user.kyc_submitted_at){
              kycBadge.title = `KYC ${label} â€¢ submitted: ${new Date(user.kyc_submitted_at).toLocaleString()}`;
            } else {
              kycBadge.title = 'KYC status: ' + label;
            }
          }
        }
        if(kycDot){
          kycDot.className = dotCls;
          if(latest && latest.admin_note) kycDot.title = 'Admin: ' + latest.admin_note;
          else kycDot.title = 'KYC: ' + label;
        }
        currentKycStatus = normalized;
      } catch(err){
        console.warn('updateKycBadge error', err);
        if(kycBadge){ kycBadge.textContent = 'Unverified'; kycBadge.className = 'kyc-badge kyc-unverified'; kycBadge.title = 'Error'; }
        if(kycDot){ kycDot.className = 'kdot kdot-unverified'; kycDot.title = 'Error'; }
        currentKycStatus = 'unverified';
      }
    }

    // update on load and poll periodically
    (function initKycBadgePolling(){
      updateKycBadge();
      setInterval(updateKycBadge, 15000);
    })();

    // Intercept clicks on any link that goes to kyc.html
    function interceptKycLinks(){
      const anchors = Array.from(document.querySelectorAll('a[href$="kyc.html"], a[href*="/kyc.html"]'));
      anchors.forEach(a => {
        if(a.dataset.kycHandlerAttached) return;
        a.dataset.kycHandlerAttached = '1';
        a.addEventListener('click', function (ev) {
          try {
            if(currentKycStatus === null){
              updateKycBadge();
            }
            if(currentKycStatus === 'verified'){
              ev.preventDefault();
              ev.stopPropagation();
              showInfoModal('Account already verified', 'Your account has already been verified. There is no need to open the KYC page.');
              return false;
            }
          } catch(e){
            console.warn('kyc link handler error', e);
          }
        }, { passive: false });
      });
    }

    document.addEventListener('DOMContentLoaded', function(){
      interceptKycLinks();
    });

    setInterval(interceptKycLinks, 5000);

    // ---------- rest of your existing job / modal code below (unchanged) ----------
    function showJobRequestModal(job, onAccept, onDecline){
      const html = `
        <h3>New job request</h3>
        <div class="muted">You have been requested for a new job. Review details and choose an action.</div>
        <div style="margin-top:10px; padding:10px; background:#fbfeff; border:1px solid #eef6ff; border-radius:10px;">
          <strong>${job.job_type || 'Job'}</strong>
          <div style="margin-top:6px;">${(job.description||'No description').slice(0,300)}</div>
          <div style="margin-top:8px; color:#374151; font-size:14px;"><strong>Price:</strong> ${job.price ? 'â‚¦' + (Number(job.price).toLocaleString?.() || job.price) : '-' } ${job.address ? (' â€¢ ' + job.address) : ''}</div>
          ${job.estimated_days ? ('<div style="margin-top:6px;"><strong>Client estimated days:</strong> ' + job.estimated_days + '</div>') : ''}
        </div>
        <div class="modal-actions">
          <button id="declineBtn" class="btn secondary">Decline</button>
          <button id="acceptBtn" class="btn">Accept</button>
        </div>
      `;
      openModal(html, { closable: false });
      document.getElementById('acceptBtn').addEventListener('click', ()=> { closeModal(); onAccept && onAccept(); });
      document.getElementById('declineBtn').addEventListener('click', ()=> { closeModal(); onDecline && onDecline(); });
    }

    function showJobReceivedModal(job, jobId, techId){
      const html = `
        <h3>Job matching successful âœ…</h3>
        <div class="muted">Job was accepted â€” client and technician can now chat.</div>
        <div style="display:flex;justify-content:center;margin-top:12px;">
          <img src="https://i.postimg.cc/8C9cKz3q/job-received.png" alt="Job Received" style="max-width:260px;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.08)" />
        </div>
        <div style="margin-top:12px;">
          <strong>Client:</strong> ${job.client_name || job.client || '-'}<br>
          <strong>Location:</strong> ${job.address || (job.city || '') || '-'}<br>
          <strong>Description:</strong> ${(job.description||'').slice(0,200)}
        </div>
        <div class="modal-actions" style="margin-top:12px;">
          <button id="receivedOk" class="btn">OK</button>
        </div>
      `;
      openModal(html, { closable: false });
      document.getElementById('receivedOk').addEventListener('click', ()=> {
        closeModal();
        const qs = 'jobId=' + encodeURIComponent(jobId || job.id) + (techId ? ('&techId=' + encodeURIComponent(techId)) : '');
        window.location.href = 'chat.html?' + qs;
      });
    }

    async function promptAcceptDecline(job){
      if(!job || !job.id) return;

      const jobId = job.id;

      try {
        if(localStorage.getItem('wc_jobSeen_' + jobId)) {
          return;
        }
      } catch(e){}

      try { localStorage.setItem('wc_jobSeen_' + jobId, '1'); } catch(e){}

      showJobRequestModal(job, async function onAccept(){
        if(pendingTimers[jobId] && pendingTimers[jobId].timeoutId) { clearTimeout(pendingTimers[jobId].timeoutId); delete pendingTimers[jobId]; }

        try {
          const resp = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/respond', {
            method: 'POST', headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ techId: getUserId(), action: 'accept' })
          });
          const js = await resp.json().catch(()=>null);
          if(resp.ok && js && js.success){
            showJobReceivedModal(job, jobId, getUserId());
          } else {
            const msg = js && js.message ? js.message : ('HTTP ' + resp.status);
            showErrorPopup('Server error', msg);
            try { localStorage.removeItem('wc_jobSeen_' + jobId); } catch(e){}
          }
        } catch(err){
          showErrorPopup('Network error', String(err));
          try { localStorage.removeItem('wc_jobSeen_' + jobId); } catch(e){}
        }
      }, async function onDecline(){
        if(pendingTimers[jobId] && pendingTimers[jobId].timeoutId) { clearTimeout(pendingTimers[jobId].timeoutId); delete pendingTimers[jobId]; }

        try {
          const resp = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/respond', {
            method: 'POST', headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ techId: getUserId(), action: 'decline' })
          });
          const js = await resp.json().catch(()=>null);
          if(resp.ok && js && js.success){
            showToast('Job declined', 2000);
          } else {
            showErrorPopup('Server error', js && js.message ? js.message : ('HTTP ' + resp.status));
            try { localStorage.removeItem('wc_jobSeen_' + jobId); } catch(e){}
          }
        } catch(err){
          showErrorPopup('Network error', String(err));
          try { localStorage.removeItem('wc_jobSeen_' + jobId); } catch(e){}
        }
      });

      pendingTimers[jobId] = { timeoutId: setTimeout(async ()=>{
        try {
          await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/respond', {
            method: 'POST', headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ techId: getUserId(), action: 'expire' })
          });
        } catch(e){}
        try { localStorage.removeItem('wc_jobSeen_' + jobId); } catch(e){}
        delete pendingTimers[jobId];
      }, 3 * 60 * 1000) };
    }

    let assignedPollInterval = null;
    async function pollAssignedJobs(techId){
      const jobs = await fetchAssignedJobs(techId);
      if(!jobs) return;
      for(const job of jobs){
        if(job.status === 'pending_accept'){
          try {
            if(localStorage.getItem('wc_jobSeen_' + job.id)) {
              if(!pendingTimers[job.id]) {
                pendingTimers[job.id] = { timeoutId: setTimeout(async ()=>{
                  try {
                    await fetch(API_BASE + '/api/job/' + encodeURIComponent(job.id) + '/respond', {
                      method: 'POST', headers: { 'Content-Type':'application/json' },
                      body: JSON.stringify({ techId: getUserId(), action: 'expire' })
                    });
                    localStorage.removeItem('wc_jobSeen_' + job.id);
                    delete pendingTimers[job.id];
                  } catch(e){}
                }, 3 * 60 * 1000) };
              }
              continue;
            }
          } catch(e){}
          await promptAcceptDecline(job);
        }
      }
    }
    function startAssignedPolling(techId){
      if(assignedPollInterval) return;
      pollAssignedJobs(techId);
      assignedPollInterval = setInterval(()=> pollAssignedJobs(techId), 5000);
    }
    function stopAssignedPolling(){ if(assignedPollInterval){ clearInterval(assignedPollInterval); assignedPollInterval = null; } 
      Object.keys(pendingTimers).forEach(k => { try { clearTimeout(pendingTimers[k].timeoutId); } catch(e){} });
      for(const k in pendingTimers) delete pendingTimers[k];
    }

    // Toggle handler
    async function handleSwitchToggle(e){
      const checked = e.target.checked;
      const role = getUserRole();
      const isTech = isTechnicianRole(role);
      if(!isTech){
        e.target.checked = false;
        showToast('Availability toggle works only for technicians', 3500);
        return;
      }
      const userId = getUserId();
      if(!userId){
        e.target.checked = false;
        showToast('No user id found, login required', 4000);
        return;
      }
      let lat=null,lng=null;
      if(navigator.geolocation){
        try {
          const pos = await new Promise((resolve,reject)=> {
            const t = setTimeout(()=>reject(new Error('geo timeout')),4500);
            navigator.geolocation.getCurrentPosition(p=>{clearTimeout(t);resolve(p);}, err=>{clearTimeout(t); reject(err);}, { maximumAge:10000, timeout:4500});
          });
          lat = pos.coords.latitude; lng = pos.coords.longitude;
        } catch(e){}
      }
      setIndicator(checked); e.target.disabled = true; showToast(checked ? 'Going online...' : 'Going offline...', 1200);
      const res = await sendStatusToBackend(userId, checked, lat, lng);
      e.target.disabled = false;
      if(res && res.success){
        storeLastKnownOnline(userId, checked);
        if(checked) startAssignedPolling(userId); else { stopAssignedPolling(); }
      } else {
        e.target.checked = !checked; setIndicator(!checked);
        showErrorPopup('Status update failed', (res && res.message) ? res.message : 'Unknown error');
      }
    }
    if(statusSwitch) statusSwitch.addEventListener('change', handleSwitchToggle);

    // init state
    (function init(){
      const role = getUserRole();
      const isTech = isTechnicianRole(role);
      const uid = getUserId();
      if(!isTech){ setIndicator(false); if(statusSwitch) statusSwitch.checked = false; stopAssignedPolling(); return; }
      const known = readLastKnownOnline(uid);
      if(known === null){ setIndicator(false); if(statusSwitch) statusSwitch.checked = false; } else { setIndicator(!!known); if(statusSwitch) statusSwitch.checked = !!known; if(known) startAssignedPolling(uid); }
      // <-- MINIMAL CHANGE: always start polling for assigned jobs for technicians
      if(uid) startAssignedPolling(uid);
    })();

    // other small features (job map, view jobs, etc) kept as-is
    document.getElementById('jobMapBtn').addEventListener('click', async ()=>{
      const userId = getUserId();
      if(!userId){ showToast('Not signed in'); return; }
      const jobs = await fetchAssignedJobs(userId);
      if(!jobs || jobs.length === 0){ showErrorPopup('No jobs', 'No pending assigned jobs found.'); return; }
      const j = jobs.find(x=>x.lat && x.lng) || jobs[0];
      if(j && j.lat && j.lng){ window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(j.lat + ',' + j.lng)}`, '_blank'); }
      else showErrorPopup('No coordinates', 'Job has no coordinates. Address: ' + (j.address || 'n/a'));
    });

    document.getElementById('viewJobsBtn').addEventListener('click', async ()=>{
      const userId = getUserId();
      if(!userId){ showToast('Not signed in'); return; }
      const jobs = await fetchAssignedJobs(userId);
      if(!jobs){ showErrorPopup('Error', 'Could not fetch jobs.'); return; }
      if(jobs.length===0){ showErrorPopup('No jobs', 'No pending assigned jobs.'); return; }
      const listHtml = jobs.map(j => `<div style="padding:8px;border-bottom:1px solid #eef6ff;"><strong>ID:</strong> ${j.id} <br><strong>Type:</strong> ${j.job_type||'-'}<br><strong>Price:</strong> ${j.price ? ('â‚¦'+j.price) : '-'}</div>`).join('');
      openModal(`<h3>Assigned / Pending jobs</h3><div class="muted">Tap a job to open chat (not implemented here)</div><div style="margin-top:8px;">${listHtml}</div><div class="modal-actions"><button id="closeJobs" class="btn">Close</button></div>`);
      document.getElementById('closeJobs').addEventListener('click', closeModal);
    });

    document.getElementById('jobRulesBtn').addEventListener('click', ()=> {
      const txt = `Job rules:\n- You have 3 minutes to accept a job (auto-expire).\n- Keep communication in-app.\n- Accept only jobs you can do.`;
      openModal(`<h3>Job Rules</h3><div class="muted">${txt.replace(/\n/g,'<br>')}</div><div class="modal-actions"><button id="closeRules" class="btn">Close</button></div>`);
      document.getElementById('closeRules').addEventListener('click', closeModal);
    });

    document.getElementById('techLeaderboardBtn').addEventListener('click', async ()=>{
      try {
        const resp = await fetch(API_BASE + '/api/dashboard?role=worker', { method:'GET' });
        if(!resp.ok) { showErrorPopup('Error','Could not fetch leaderboard'); return; }
        const data = await resp.json().catch(()=>null);
        if(!data || !data.success || !Array.isArray(data.leaderboard)) { showErrorPopup('No data','No leaderboard data'); return; }
        const list = data.leaderboard.map((t,i)=> `${i+1}. ${t.fullname || t.username} â€” ${t.jobs_completed || 0}`).join('<br>');
        openModal(`<h3>Top Technicians</h3><div class="muted">${list}</div><div class="modal-actions"><button id="closeLB" class="btn">Close</button></div>`);
        document.getElementById('closeLB').addEventListener('click', closeModal);
      } catch(e){ showErrorPopup('Error', String(e)); }
    });

    // logout
    logoutBtn.addEventListener('click', (ev) => {
      ev.preventDefault();
      try { const u = getLocalUser(); if(u && u.id) localStorage.removeItem('techOnline_' + u.id); } catch(e) {}
      localStorage.removeItem('wc_user'); localStorage.removeItem('wc_token'); localStorage.removeItem('userId'); localStorage.removeItem('userRole'); localStorage.removeItem('wc_online');
      stopAssignedPolling();
      window.location.href = 'login.html';
    });

    // hamburger logic
    (function(){
      const btn = hamburgerBtn, menu = menuDropdown;
      btn.addEventListener('click', (e)=> { e.stopPropagation(); const shown = menu.style.display === 'block'; menu.style.display = shown ? 'none' : 'block'; btn.setAttribute('aria-expanded', String(!shown)); menu.setAttribute('aria-hidden', String(shown)); });
      document.addEventListener('click', (e)=> { const container = document.querySelector('.hamburger-container'); if(!container.contains(e.target)){ menu.style.display = 'none'; btn.setAttribute('aria-expanded','false'); menu.setAttribute('aria-hidden','true'); } });
    })();

    // modal backdrop close on escape & click outside (honors closable flag)
    document.addEventListener('keydown', (e)=> { if(e.key === 'Escape') { if(modal._closable !== false) closeModal(); } });
    modalBackdrop.addEventListener('click', (e)=> { if(e.target === modalBackdrop && modal._closable !== false) closeModal(); });

    // ensure polling stops on unload
    window.addEventListener('beforeunload', ()=> { stopAssignedPolling(); });

  </script>
</body>
</html>
