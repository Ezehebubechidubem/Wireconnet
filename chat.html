<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WireConnect — Chat</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body{font-family:Inter,Arial;margin:0;background:#f6f8fb;color:#111}
    header{display:flex;align-items:center;gap:12px;padding:10px;background:linear-gradient(135deg,#0b5cff,#55a7ff);color:#fff;position:relative}
    .logo img{height:36px}
    .container{display:flex;gap:12px;padding:12px;max-width:1100px;margin:12px auto;flex-direction:column}
    .panel{width:100%;background:#fff;border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(16,24,40,0.06)}
    .chat-window{height:360px;overflow:auto;border:1px solid #eef2ff;padding:12px;border-radius:8px;background:#fbfeff}
    .chat-input{display:flex;gap:8px;margin-top:8px}
    .btn{background:#0b5cff;color:#fff;padding:8px 10px;border-radius:8px;border:0;cursor:pointer}
    .muted{color:#64748b}
    #map{height:320px;border-radius:8px;margin-top:12px;display:none}
    .top-row{display:flex;align-items:center;justify-content:space-between}
    .countdown{background:rgba(255,255,255,0.15);padding:6px 10px;border-radius:8px;font-weight:700}
    /* small message bubble tweaks */
    .msg-time{font-size:11px;color:#64748b}
  </style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <img src="https://i.postimg.cc/ZRSK3pJx/IMG-20260202-144108.png" style="height:36px;object-fit:contain" alt="logo">
      <div style="font-weight:700">WireConnect — Job Chat</div>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <button id="toggleMapBtn" class="btn" style="background:#fff;color:#0b5cff;border:1px solid rgba(11,92,255,0.2)">Show map</button>
      <div id="jobCountdown" class="countdown" aria-live="polite">—</div>
    </div>
  </header>

  <div class="container">
    <div class="panel">
      <div class="top-row" style="margin-bottom:8px">
        <div>
          <strong id="peerName">Peer</strong><div class="muted" id="peerRole">Role</div>
        </div>
        <div class="muted" id="jobStatus">Loading job...</div>
      </div>

      <div id="chatWindow" class="chat-window" aria-live="polite"></div>

      <div class="chat-input">
        <input id="chatText" placeholder="Write a message..." style="flex:1;padding:8px;border-radius:8px;border:1px solid #eef2ff">
        <button id="sendBtn" class="btn">Send</button>
      </div>

      <div id="map" aria-hidden="true"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    (function(){
      const API_BASE = 'https://wireconnet-1.onrender.com';
      const params = new URLSearchParams(location.search);
      const jobId = params.get('jobId');
      const urlTechId = params.get('techId'); // optional direct tech id

      if(!jobId){ alert('No job specified'); location.href = 'dashboard.html'; }

      // DOM
      const chatWindow = document.getElementById('chatWindow');
      const sendBtn = document.getElementById('sendBtn');
      const chatText = document.getElementById('chatText');
      const peerNameEl = document.getElementById('peerName');
      const peerRoleEl = document.getElementById('peerRole');
      const jobStatusEl = document.getElementById('jobStatus');
      const jobCountdownEl = document.getElementById('jobCountdown');
      const toggleMapBtn = document.getElementById('toggleMapBtn');
      const mapEl = document.getElementById('map');

      // local user
      function loadUser(){ try{ const raw = localStorage.getItem('wc_user'); return raw ? JSON.parse(raw) : null; }catch(e){return null} }
      const me = loadUser();

      // storage key for caching messages
      const storageKey = 'wc_chat_' + jobId;

      // render messages (ordered ascending by time)
      function renderMessagesArray(msgs){
        msgs.sort((a,b)=> (a.t || 0) - (b.t || 0));
        chatWindow.innerHTML = msgs.map(m=>{
          const time = new Date(m.t).toLocaleTimeString();
          const bubbleBg = m.own ? '#e6f0ff' : '#fff';
          const align = m.own ? 'flex-end' : 'flex-start';
          let senderLabel = '';
          if(!m.own && m.senderName) senderLabel = `<div style="font-size:12px;color:#334155;font-weight:700;margin-bottom:6px">${escapeHtml(m.senderName)}</div>`;
          return `<div style="display:flex;justify-content:${align};margin-bottom:10px"><div style="max-width:78%">${senderLabel}<div class="msg-time">${time}</div><div style="padding:10px;background:${bubbleBg};border-radius:8px;margin-top:6px">${escapeHtml(m.text)}</div></div></div>`;
        }).join('');
        chatWindow.scrollTop = chatWindow.scrollHeight;
      }

      function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

      // fetch messages from backend
      async function fetchMessagesFromServer(){
        try{
          const r = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/messages', { cache:'no-store' });
          if(!r.ok) return null;
          const js = await r.json().catch(()=>null);
          if(!js || !js.success) return null;
          return js.messages || [];
        }catch(e){
          return null;
        }
      }

      // merge server messages into local cache and return canonical array
      async function syncMessages(){
        const remote = await fetchMessagesFromServer();
        let local = [];
        try{ local = JSON.parse(localStorage.getItem(storageKey) || '[]'); }catch(e){ local = []; }

        if(!remote) {
          // no server result; just render local
          renderMessagesArray(local);
          return;
        }

        // build map by unique key (prefer server id if present)
        const byKey = new Map();
        for(const m of local){
          const key = m.serverId ? 's:'+m.serverId : ('l:'+m.t+'|'+m.text);
          byKey.set(key, m);
        }

        // for each remote message, add if missing
        for(const r of remote){
          const t = new Date(r.created_at).getTime();
          const key = r.id ? 's:'+r.id : ('r:'+t+'|'+r.text);
          if(!byKey.has(key)){
            const own = me && (me.id == r.sender_id || me.userId == r.sender_id || me._id == r.sender_id);
            byKey.set(key, {
              t,
              text: r.text || '',
              own: !!own,
              serverId: r.id || null,
              senderId: r.sender_id || null
            });
          } else {
            // update existing with possible serverId
            const existing = byKey.get(key);
            if(!existing.serverId && r.id) existing.serverId = r.id;
            if(!existing.senderId && r.sender_id) existing.senderId = r.sender_id;
            existing.t = new Date(r.created_at).getTime();
            existing.text = r.text || existing.text;
          }
        }

        // convert to array
        const merged = Array.from(byKey.values());

        // annotate sender names by fetching minimal user info for unknown senderIds
        const unknownSenderIds = new Set();
        for(const m of merged){
          if(!m.own && m.senderId && !m.senderName){
            unknownSenderIds.add(m.senderId);
          }
        }
        if(unknownSenderIds.size){
          // fetch profiles in parallel (limit to avoid many requests)
          await Promise.all(Array.from(unknownSenderIds).map(async sid=>{
            try{
              const r = await fetch(API_BASE + '/api/user/' + encodeURIComponent(sid));
              if(!r.ok) return;
              const u = await r.json().catch(()=>null);
              // server returns success true with user details or sometimes the row directly
              const profile = (u && u.success && u.fullname) ? u : (u && u.id ? u : null);
              const name = profile ? (profile.fullname || profile.username || ('tech-'+sid)) : ('user-'+sid);
              // apply
              for(const m of merged) if(m.senderId == sid) m.senderName = name;
            }catch(e){}
          }));
        }

        // ensure own messages show 'You' label? we'll keep them unlabelled
        // save merged to localStorage for offline use
        try{ localStorage.setItem(storageKey, JSON.stringify(merged)); }catch(e){}
        renderMessagesArray(merged);
      }

      // send message
      let sending = false;
      sendBtn.addEventListener('click', async ()=>{
        const txt = chatText.value.trim(); if(!txt || sending) return;
        if(!me || !me.id){ alert('Please sign in to send messages'); return; }
        sending = true;
        sendBtn.disabled = true;
        // optimistic UI: append local message immediately (keeps user feeling responsive)
        const optimistic = { t: Date.now(), text: txt, own: true, serverId: null, senderId: me.id };
        try{
          // append to local cache
          let local = [];
          try{ local = JSON.parse(localStorage.getItem(storageKey) || '[]'); }catch(e){ local = []; }
          local.push(optimistic);
          localStorage.setItem(storageKey, JSON.stringify(local));
          renderMessagesArray(local);
        } catch(e){}

        // send to backend
        try{
          const resp = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ senderId: me.id, text: txt })
          });
          if(!resp.ok){
            // leave optimistic but alert
            alert('Message could not be sent (server error). It will be retried on next poll.');
          } else {
            // refresh from server to get canonical list
            await syncMessages();
          }
        }catch(e){
          alert('Network error: message not sent. It will be retried on next poll.');
        } finally {
          chatText.value = '';
          sending = false;
          sendBtn.disabled = false;
        }
      });

      // helper: fetch job status and update UI / peer name
      async function fetchJobStatusAndUpdate(){
        try{
          const r = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/status', { cache:'no-store' });
          if(!r.ok) return null;
          const js = await r.json().catch(()=>null);
          if(!js || !js.success) return null;
          const job = js.job;
          jobStatusEl.textContent = `Status: ${job.status || '—'}`;
          // if assigned, fetch technician name
          if(job.assigned_tech_id){
            try{
              const tr = await fetch(API_BASE + '/api/user/' + encodeURIComponent(job.assigned_tech_id), { cache:'no-store' });
              if(tr.ok){
                const tjs = await tr.json().catch(()=>null);
                const profile = (tjs && tjs.success && tjs.id) ? tjs : (tjs && tjs.id ? tjs : (tjs && tjs.fullname ? tjs : null));
                const name = profile ? (profile.fullname || profile.username || ('Tech')) : 'Technician';
                peerNameEl.textContent = name;
                peerRoleEl.textContent = 'Technician';
              } else {
                peerNameEl.textContent = 'Assigned Technician';
                peerRoleEl.textContent = 'Technician';
              }
            }catch(e){}
          } else {
            // If there's a techId in URL param, show it
            if(urlTechId){
              try{
                const tr = await fetch(API_BASE + '/api/user/' + encodeURIComponent(urlTechId), { cache:'no-store' });
                if(tr.ok){
                  const tjs = await tr.json().catch(()=>null);
                  const profile = (tjs && tjs.success && tjs.id) ? tjs : (tjs && tjs.id ? tjs : (tjs && tjs.fullname ? tjs : null));
                  const name = profile ? (profile.fullname || profile.username || 'Technician') : 'Technician';
                  peerNameEl.textContent = name;
                  peerRoleEl.textContent = 'Technician';
                }
              }catch(e){}
            } else {
              // fallback: show other party as "Peer"
              peerNameEl.textContent = 'Peer';
              peerRoleEl.textContent = '';
            }
          }

          // handle expires_at countdown
          if(job.expires_at){
            startCountdown(new Date(job.expires_at).getTime());
          }
          return job;
        }catch(e){
          return null;
        }
      }

      // countdown for job expiry
      let countdownInterval = null;
      function startCountdown(expiresTs){
        if(countdownInterval) clearInterval(countdownInterval);
        function update(){
          const now = Date.now();
          let diff = Math.max(0, expiresTs - now);
          const d = Math.floor(diff / (24*3600*1000)); diff %= 24*3600*1000;
          const h = Math.floor(diff / (3600*1000)); diff %= 3600*1000;
          const m = Math.floor(diff / (60*1000));
          jobCountdownEl.textContent = `${d}d ${h}h ${m}m`;
          if(expiresTs <= now){ jobCountdownEl.textContent = 'Expired'; clearInterval(countdownInterval); countdownInterval = null; }
        }
        update();
        countdownInterval = setInterval(update, 60*1000);
      }

      // polling loop
      async function pollEverything(){
        await syncMessages();
        await fetchJobStatusAndUpdate();
      }

      // Start polls
      pollEverything();
      setInterval(pollEverything, 3000); // every 3s keeps both sides fairly real-time

      // Map & routing:
      let map=null, techMarker=null, clientMarker=null, routeLayer=null;
      toggleMapBtn.addEventListener('click', async ()=>{
        const showing = mapEl.style.display !== 'block';
        mapEl.style.display = showing ? 'block' : 'none';
        toggleMapBtn.innerText = showing ? 'Hide map' : 'Show map';
        if(showing){
          if(!map) initMap();
          await updateMapRoute();
        }
      });

      function initMap(){
        map = L.map('map', { center:[9.0820,8.6753], zoom:6 });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'© OpenStreetMap' }).addTo(map);
      }

      // helper to get client coords: prefer wc_last_lat/lng, else me.lat/lng
      function getClientCoords(){
        const latLS = parseFloat(localStorage.getItem('wc_last_lat') || 'NaN');
        const lngLS = parseFloat(localStorage.getItem('wc_last_lng') || 'NaN');
        if(Number.isFinite(latLS) && Number.isFinite(lngLS)) return [latLS, lngLS];
        if(me && me.lat && me.lng) return [Number(me.lat), Number(me.lng)];
        return null;
      }

      // fetch assigned tech id from job status
      async function getAssignedTechId(){
        try{
          const r = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/status', { cache:'no-store' });
          if(!r.ok) return urlTechId || null;
          const js = await r.json().catch(()=>null);
          if(!js || !js.success) return urlTechId || null;
          return js.job && js.job.assigned_tech_id ? js.job.assigned_tech_id : (urlTechId || null);
        }catch(e){
          return urlTechId || null;
        }
      }

      async function fetchUserProfile(id){
        try{
          const r = await fetch(API_BASE + '/api/user/' + encodeURIComponent(id), { cache:'no-store' });
          if(!r.ok) return null;
          const js = await r.json().catch(()=>null);
          // server may return { success:true, ... } or we might get user row directly
          if(js && js.success && (js.id || js.fullname)) return js;
          if(js && js.id) return js;
          return null;
        }catch(e){ return null; }
      }

      async function updateMapRoute(){
        const clientCoords = getClientCoords();
        const assignedTechId = await getAssignedTechId();
        let techCoords = null;
        let techProfile = null;
        if(assignedTechId){
          techProfile = await fetchUserProfile(assignedTechId);
          if(techProfile && techProfile.lat && techProfile.lng) techCoords = [Number(techProfile.lat), Number(techProfile.lng)];
        }

        // clear existing
        if(routeLayer){ routeLayer.remove(); routeLayer=null; }
        if(clientMarker){ clientMarker.remove(); clientMarker=null; }
        if(techMarker){ techMarker.remove(); techMarker=null; }

        if(clientCoords){
          clientMarker = L.marker([clientCoords[0], clientCoords[1]]).addTo(map).bindPopup('Client');
        }
        if(techCoords){
          techMarker = L.marker([techCoords[0], techCoords[1]]).addTo(map).bindPopup('Technician');
        }

        if(clientCoords && techCoords){
          try{
            const from = `${techCoords[1]},${techCoords[0]}`;
            const to   = `${clientCoords[1]},${clientCoords[0]}`;
            const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${from};${to}?overview=full&geometries=geojson&steps=false`;
            const r = await fetch(osrmUrl);
            if(r.ok){
              const js = await r.json();
              if(js && js.routes && js.routes.length){
                const route = js.routes[0];
                const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
                routeLayer = L.polyline(coords, { color:'#0b5cff', weight:5, opacity:0.85 }).addTo(map);
                map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
                // display ETA in jobStatusEl
                const mins = Math.round((route.duration||0)/60);
                const distKm = ((route.distance||0)/1000).toFixed(1);
                jobStatusEl.textContent = `ETA: ${mins} min • ${distKm} km`;
              }
            }
          }catch(e){
            console.warn('OSRM error', e);
          }
        } else if(clientCoords){
          map.setView([clientCoords[0], clientCoords[1]], 12);
        } else if(techCoords){
          map.setView([techCoords[0], techCoords[1]], 12);
        } else {
          // nothing to show
          map.setView([9.0820,8.6753], 6);
        }
      }

      // keep map updated periodically if visible
      setInterval(()=>{ if(mapEl.style.display === 'block') updateMapRoute(); }, 10000);

      // ensure we try once on load if user toggled manually
      // also re-fetch messages immediately on load
      (async function initial(){
        await syncMessages();
        await fetchJobStatusAndUpdate();
      })();

      // When page visible, refresh
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden){ syncMessages(); fetchJobStatusAndUpdate(); if(mapEl.style.display==='block') updateMapRoute(); } });

    })();
  </script>
</body>
</html>