<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WireConnect — Chat</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body{font-family:Inter,Arial;margin:0;background:#f6f8fb;color:#111}
    header{display:flex;align-items:center;gap:12px;padding:10px;background:linear-gradient(135deg,#0b5cff,#55a7ff);color:#fff;position:relative}
    .logo img{height:36px}
    .container{display:flex;gap:12px;padding:12px;max-width:1100px;margin:12px auto;flex-direction:column}
    .panel{width:100%;background:#fff;border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(16,24,40,0.06)}
    .chat-window{height:360px;overflow:auto;border:1px solid #eef2ff;padding:12px;border-radius:8px;background:#fbfeff}
    .chat-input{display:flex;gap:8px;margin-top:8px}
    .btn{background:#0b5cff;color:#fff;padding:8px 10px;border-radius:8px;border:0;cursor:pointer}
    .muted{color:#64748b}
    #map{height:320px;border-radius:8px;margin-top:12px;display:none}
    .top-row{display:flex;align-items:center;justify-content:space-between}
    .countdown{background:rgba(255,255,255,0.15);padding:6px 10px;border-radius:8px;font-weight:700}
    /* small message styles */
    .msg-time{font-size:11px;color:#64748b}
    .msg-bubble{padding:10px;border-radius:8px;margin-top:6px;word-break:break-word;display:inline-block;max-width:78%}
    .msg-row{display:flex;margin-bottom:10px}
    .msg-row.me{justify-content:flex-end}
    .msg-row.other{justify-content:flex-start}
  </style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <img src="https://i.postimg.cc/ZRSK3pJx/IMG-20260202-144108.png" style="height:36px;object-fit:contain" alt="logo">
      <div style="font-weight:700">WireConnect — Job Chat</div>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <button id="toggleMapBtn" class="btn" style="background:#fff;color:#0b5cff;border:1px solid rgba(11,92,255,0.2)">Show map</button>
      <div id="jobCountdown" class="countdown" aria-live="polite">—</div>
    </div>
  </header>

  <div class="container">
    <div class="panel">
      <div class="top-row" style="margin-bottom:8px">
        <div>
          <strong id="peerName">Peer</strong><div class="muted" id="peerRole">Role</div>
        </div>
        <div class="muted" id="jobStatus">Loading job...</div>
      </div>

      <div id="chatWindow" class="chat-window" aria-live="polite" role="log" aria-atomic="false"></div>

      <div class="chat-input">
        <input id="chatText" placeholder="Write a message..." style="flex:1;padding:8px;border-radius:8px;border:1px solid #eef2ff" aria-label="Message input">
        <button id="sendBtn" class="btn">Send</button>
      </div>

      <div id="map" aria-hidden="true"></div>
    </div>
  </div>

  <!-- Leaflet + PolylineDecorator for arrows -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.7.0/leaflet.polylineDecorator.min.js"></script>

  <script>
  (function(){
    const API_BASE = 'https://wireconnet-1.onrender.com';

    // query string
    const params = new URLSearchParams(location.search);
    const jobId = params.get('jobId');
    const urlTechId = params.get('techId');

    // DOM nodes
    const chatWindow = document.getElementById('chatWindow');
    const sendBtn = document.getElementById('sendBtn');
    const chatText = document.getElementById('chatText');
    const peerNameEl = document.getElementById('peerName');
    const peerRoleEl = document.getElementById('peerRole');
    const jobStatusEl = document.getElementById('jobStatus');
    const jobCountdownEl = document.getElementById('jobCountdown');
    const toggleMapBtn = document.getElementById('toggleMapBtn');
    const mapEl = document.getElementById('map');

    if(!jobId){ alert('No job specified'); location.href = 'dashboard.html'; return; }

    // load local user (must be set by login flow)
    function loadUser(){ try{ const raw = localStorage.getItem('wc_user'); return raw ? JSON.parse(raw) : null; }catch(e){return null;} }
    const me = loadUser();
    if(!me){ /* allow viewing if needed but sending requires login */ }

    // Render messages from an array returned by server.
    function renderMessages(messages){
      // messages should be array sorted asc by created_at
      chatWindow.innerHTML = '';
      messages.forEach(m => {
        const createdTs = new Date(m.created_at).getTime ? new Date(m.created_at).getTime() : Date.parse(m.created_at);
        const time = isNaN(createdTs) ? '' : new Date(createdTs).toLocaleTimeString();
        const isMe = me && (String(m.sender_id) === String(me.id));
        const row = document.createElement('div');
        row.className = 'msg-row ' + (isMe ? 'me' : 'other');
        const inner = document.createElement('div');
        inner.innerHTML = `
          <div class="msg-time">${time}</div>
          <div class="msg-bubble" style="background:${isMe ? '#e6f0ff' : '#fff'}">${escapeHtml(m.text)}</div>
        `;
        row.appendChild(inner);
        chatWindow.appendChild(row);
      });
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

    // Fetch messages from backend and render.
    // The backend must return { success: true, messages: [...] } and messages sorted asc (oldest first).
    async function fetchMessages(){
      try{
        const res = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/messages');
        if(!res.ok) return;
        const js = await res.json().catch(()=>null);
        if(!js || !js.success) return;
        // Ensure sort by created_at asc
        const messages = Array.isArray(js.messages) ? js.messages.slice().sort((a,b)=> new Date(a.created_at) - new Date(b.created_at)) : [];
        renderMessages(messages);
      }catch(err){
        // network issues silently ignored (UI still usable)
        console.warn('fetchMessages error', err);
      }
    }

    // Send message: POST -> then refresh messages
    async function sendMessage(text){
      if(!me || !me.id){
        alert('Please login to send messages.');
        return;
      }
      const payload = { senderId: me.id, text };
      // disable send to avoid duplicates while awaiting
      sendBtn.disabled = true;
      try{
        const r = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/message', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const js = await r.json().catch(()=>null);
        if(!r.ok){
          console.warn('sendMessage failed', js || r.statusText);
        }
      }catch(err){
        console.warn('Network error sending message', err);
      } finally {
        sendBtn.disabled = false;
        chatText.value = '';
        // refresh messages from server (best-effort)
        fetchMessages();
      }
    }

    // wire send button & enter key
    sendBtn.addEventListener('click', ()=> {
      const t = chatText.value.trim();
      if(!t) return;
      sendMessage(t);
    });
    chatText.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); }
    });

    // --- MAP / ROUTE / ARROWS (unchanged, kept) ---
    let map = null, routeLayer = null, decorator = null, jobMarker = null, techMarker = null;
    let showMap = false;

    toggleMapBtn.addEventListener('click', async ()=>{
      showMap = !showMap;
      if(showMap){
        mapEl.style.display = 'block';
        toggleMapBtn.innerText = 'Hide map';
        if(!map) initMap();
        await updateMapRouteWithArrows();
      } else {
        mapEl.style.display = 'none';
        toggleMapBtn.innerText = 'Show map';
      }
    });

    function initMap(){
      map = L.map('map', { center:[9.0820,8.6753], zoom:6 });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'© OpenStreetMap' }).addTo(map);
    }

    async function fetchJobFull(){
      try{
        const r = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId));
        if(r.ok){
          const js = await r.json().catch(()=>null);
          if(js && js.success && js.job) return js.job;
          if(js && js.job) return js.job;
        }
      }catch(e){}
      try{
        const r2 = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/status');
        if(r2.ok){
          const s = await r2.json().catch(()=>null);
          if(s && s.success && s.job) return s.job;
        }
      }catch(e){}
      return null;
    }

    async function fetchTechProfile(techId){
      if(!techId) return null;
      try{
        const r = await fetch(API_BASE + '/api/user/' + encodeURIComponent(techId));
        if(!r.ok) return null;
        const js = await r.json().catch(()=>null);
        if(js && js.success) return js.user || js;
        return js;
      }catch(e){ return null; }
    }

    async function updateMapRouteWithArrows(){
      if(!map) initMap();
      const job = await fetchJobFull();
      const techId = urlTechId || (job && job.assigned_tech_id);
      const tech = techId ? await fetchTechProfile(techId) : null;
      const clientCoords = job && job.lat && job.lng ? [Number(job.lat), Number(job.lng)] : null;
      const techCoords = tech && tech.lat && tech.lng ? [Number(tech.lat), Number(tech.lng)] : null;

      let fallbackClientLat = parseFloat(localStorage.getItem('wc_last_lat') || 'NaN');
      let fallbackClientLng = parseFloat(localStorage.getItem('wc_last_lng') || 'NaN');
      const clientFallback = Number.isFinite(fallbackClientLat) && Number.isFinite(fallbackClientLng) ? [fallbackClientLat, fallbackClientLng] : null;

      if(routeLayer){ routeLayer.remove(); routeLayer = null; }
      if(decorator){ decorator.remove(); decorator = null; }
      if(jobMarker){ jobMarker.remove(); jobMarker = null; }
      if(techMarker){ techMarker.remove(); techMarker = null; }

      const finalClient = clientCoords || clientFallback;
      const finalTech = techCoords || null;

      if(finalClient) jobMarker = L.marker([finalClient[0], finalClient[1]]).addTo(map).bindPopup('Client');
      if(finalTech) techMarker = L.marker([finalTech[0], finalTech[1]]).addTo(map).bindPopup('Technician');

      if(finalClient && finalTech){
        try{
          const from = `${finalTech[1]},${finalTech[0]}`;
          const to   = `${finalClient[1]},${finalClient[0]}`;
          const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${from};${to}?overview=full&geometries=geojson&annotations=duration,distance`;
          const r = await fetch(osrmUrl);
          if(r.ok){
            const js = await r.json();
            if(js && js.routes && js.routes.length){
              const route = js.routes[0];
              const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
              routeLayer = L.polyline(coords, { color:'#0b5cff', weight:5, opacity:0.9 }).addTo(map);
              decorator = L.polylineDecorator(routeLayer, {
                patterns: [
                  { offset: 12, repeat: 24, symbol: L.Symbol.arrowHead({ pixelSize: 10, polygon: false, pathOptions: { stroke: true, color: '#0b5cff', weight: 1 } }) }
                ]
              }).addTo(map);
              map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
              const minutes = Math.max(0, Math.round((route.duration || 0) / 60));
              const distanceKm = ((route.distance || 0) / 1000).toFixed(1);
              jobStatusEl.textContent = `ETA: ${minutes} min • ${distanceKm} km`;
            }
          }
        }catch(e){
          console.warn('OSRM route error', e);
          if(finalClient) map.setView([finalClient[0], finalClient[1]], 12);
          else if(finalTech) map.setView([finalTech[0], finalTech[1]], 12);
        }
      } else if(finalClient){
        map.setView([finalClient[0], finalClient[1]], 12);
      } else if(finalTech){
        map.setView([finalTech[0], finalTech[1]], 12);
      } else {
        map.setView([9.0820,8.6753], 6);
      }
    }

    // JOB STATUS & COUNTDOWN
    let countdownInterval = null;
    async function fetchJobStatus(){
      try{
        const res = await fetch(API_BASE + '/api/job/' + encodeURIComponent(jobId) + '/status');
        if(!res.ok) return;
        const js = await res.json().catch(()=>null);
        if(!js || !js.success) return;
        const job = js.job;
        jobStatusEl.textContent = `Status: ${job.status || '—'}`;

        if(job.assigned_tech_id){
          const t = await fetchTechProfile(job.assigned_tech_id);
          const name = (t && (t.fullname || t.username)) ? (t.fullname || t.username) : ('Tech ' + job.assigned_tech_id);
          peerNameEl.textContent = name;
          peerRoleEl.textContent = 'Technician';
        }

        let expires = null;
        if(job.expires_at) expires = new Date(job.expires_at).getTime();
        if(expires){
          startCountdown(expires);
        } else {
          jobCountdownEl.textContent = '—';
          if(countdownInterval){ clearInterval(countdownInterval); countdownInterval = null; }
        }
      }catch(e){ console.warn('fetchJobStatus error', e); }
    }
    function startCountdown(expiresTs){
      if(countdownInterval) clearInterval(countdownInterval);
      function update(){
        const now = Date.now();
        let diff = Math.max(0, expiresTs - now);
        const d = Math.floor(diff / (24*3600*1000)); diff %= 24*3600*1000;
        const h = Math.floor(diff / (3600*1000)); diff %= 3600*1000;
        const m = Math.floor(diff / (60*1000)); diff %= 60*1000;
        jobCountdownEl.textContent = `${d}d ${h}h ${m}m`;
        if(expiresTs <= now){ jobCountdownEl.textContent = 'Expired'; clearInterval(countdownInterval); countdownInterval = null; }
      }
      update();
      countdownInterval = setInterval(update, 1000 * 60);
    }

    // POLLING: messages & job status & map updates
    setInterval(fetchMessages, 2500);  // messages frequently
    setInterval(fetchJobStatus, 5000); // job status
    setInterval(()=>{ if(mapEl.style.display !== 'none') updateMapRouteWithArrows(); }, 12000);

    // initial runs
    fetchMessages();
    fetchJobStatus();

    // refresh on visibility change
    document.addEventListener('visibilitychange', ()=> {
      if(!document.hidden){
        fetchMessages();
        fetchJobStatus();
        if(mapEl.style.display !== 'none') updateMapRouteWithArrows();
      }
    });

    // expose helpers for debug
    window.__wc_fetchMessages = fetchMessages;
    window.__wc_fetchJobStatus = fetchJobStatus;
    window.__wc_updateMap = updateMapRouteWithArrows;
  })();
  </script>
</body>
</html>